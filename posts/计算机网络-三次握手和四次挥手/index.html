<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>计算机网络-三次握手和四次挥手 | test</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="三次握手和四次挥手 三次握手 概念 为什么需要握手：握手的作用就是为了同步一些信息，比如最大滑动窗口
TCP：是一个可靠的连接，也就是客户端和服务器双方必须感知对方的存在，也就是需要经历一个建立连接的过程
用三次握手建立TCP连接，连接有三个阶段
建立连接 数据传输 连接释放 连接的管理就是使连接的建立和释放都能正常地进行，连接阶段过程中要解决以下三个问题
要使每一方都能确知对方的存在 要允许双方协商一些参数 能够对运输实体分配资源 TCP连接建立过程 TCP建立连接的过程：被称为握手
① 握手过程其实是发送的TCP报文，在这里面有两个字段，SYN 和 seq
SYN = 1：表示w该报文不能携带数据，但是需要消耗一个SEQ（序号），可以想象成我们对消息编号 seq：TCP的每个字节发送的时候，都有一个序号，主要是为了保证可靠性，比如当我服务器通过TCP报文得到了有N个字节需要接受，但是最后只接受到了N-1个，我们通过序号就知道哪个没有被接收到。 客户端进入SYN_SENT状态，即同步已发送 ② 当服务器接受到我们的握手请求时，会回复一个确认报文
SYN：表示不携带数据，同时消耗一个SEQ = y（这里的y是任意数字，可以是1,2,3,4） ACK：=1 表示这是一条确定报文 ack：x+1，其中x是刚刚客户端发送过来的 服务器进入SYN_RECVD状态，即同步已收到 ③ 当客户端收到确认报文的时候，客户端需要对这个确认报文进行回复
ACK：=1，表示这是一条确认报文 seq：= x +1， ack：= y+1 经过了这三次握手，两者就进入了连接状态
通俗的理解 客户端：服务器，我们可以建立连接么？ -> SYN= 1 ， seq = x 服务器：可以啊，我们建立连接吧 ！ -> ACK =1, SYN = 1, seq = y, ack = x+1 客户端：收到，建立连接吧！ -> ACK = 1, SYN = 1，seq = x + 1， ack = y + 1 然后建立TCP连接"><meta name=generator content="Hugo 0.109.0"><meta name=robots content="noindex, nofollow"><link rel=stylesheet href=/ananke/css/main.min.css><meta property="og:title" content="计算机网络-三次握手和四次挥手"><meta property="og:description" content="三次握手和四次挥手 三次握手 概念 为什么需要握手：握手的作用就是为了同步一些信息，比如最大滑动窗口
TCP：是一个可靠的连接，也就是客户端和服务器双方必须感知对方的存在，也就是需要经历一个建立连接的过程
用三次握手建立TCP连接，连接有三个阶段
建立连接 数据传输 连接释放 连接的管理就是使连接的建立和释放都能正常地进行，连接阶段过程中要解决以下三个问题
要使每一方都能确知对方的存在 要允许双方协商一些参数 能够对运输实体分配资源 TCP连接建立过程 TCP建立连接的过程：被称为握手
① 握手过程其实是发送的TCP报文，在这里面有两个字段，SYN 和 seq
SYN = 1：表示w该报文不能携带数据，但是需要消耗一个SEQ（序号），可以想象成我们对消息编号 seq：TCP的每个字节发送的时候，都有一个序号，主要是为了保证可靠性，比如当我服务器通过TCP报文得到了有N个字节需要接受，但是最后只接受到了N-1个，我们通过序号就知道哪个没有被接收到。 客户端进入SYN_SENT状态，即同步已发送 ② 当服务器接受到我们的握手请求时，会回复一个确认报文
SYN：表示不携带数据，同时消耗一个SEQ = y（这里的y是任意数字，可以是1,2,3,4） ACK：=1 表示这是一条确定报文 ack：x+1，其中x是刚刚客户端发送过来的 服务器进入SYN_RECVD状态，即同步已收到 ③ 当客户端收到确认报文的时候，客户端需要对这个确认报文进行回复
ACK：=1，表示这是一条确认报文 seq：= x +1， ack：= y+1 经过了这三次握手，两者就进入了连接状态
通俗的理解 客户端：服务器，我们可以建立连接么？ -> SYN= 1 ， seq = x 服务器：可以啊，我们建立连接吧 ！ -> ACK =1, SYN = 1, seq = y, ack = x+1 客户端：收到，建立连接吧！ -> ACK = 1, SYN = 1，seq = x + 1， ack = y + 1 然后建立TCP连接"><meta property="og:type" content="article"><meta property="og:url" content="https://Zelayan.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-01-16T10:04:25+08:00"><meta property="article:modified_time" content="2023-01-16T10:04:25+08:00"><meta itemprop=name content="计算机网络-三次握手和四次挥手"><meta itemprop=description content="三次握手和四次挥手 三次握手 概念 为什么需要握手：握手的作用就是为了同步一些信息，比如最大滑动窗口
TCP：是一个可靠的连接，也就是客户端和服务器双方必须感知对方的存在，也就是需要经历一个建立连接的过程
用三次握手建立TCP连接，连接有三个阶段
建立连接 数据传输 连接释放 连接的管理就是使连接的建立和释放都能正常地进行，连接阶段过程中要解决以下三个问题
要使每一方都能确知对方的存在 要允许双方协商一些参数 能够对运输实体分配资源 TCP连接建立过程 TCP建立连接的过程：被称为握手
① 握手过程其实是发送的TCP报文，在这里面有两个字段，SYN 和 seq
SYN = 1：表示w该报文不能携带数据，但是需要消耗一个SEQ（序号），可以想象成我们对消息编号 seq：TCP的每个字节发送的时候，都有一个序号，主要是为了保证可靠性，比如当我服务器通过TCP报文得到了有N个字节需要接受，但是最后只接受到了N-1个，我们通过序号就知道哪个没有被接收到。 客户端进入SYN_SENT状态，即同步已发送 ② 当服务器接受到我们的握手请求时，会回复一个确认报文
SYN：表示不携带数据，同时消耗一个SEQ = y（这里的y是任意数字，可以是1,2,3,4） ACK：=1 表示这是一条确定报文 ack：x+1，其中x是刚刚客户端发送过来的 服务器进入SYN_RECVD状态，即同步已收到 ③ 当客户端收到确认报文的时候，客户端需要对这个确认报文进行回复
ACK：=1，表示这是一条确认报文 seq：= x +1， ack：= y+1 经过了这三次握手，两者就进入了连接状态
通俗的理解 客户端：服务器，我们可以建立连接么？ -> SYN= 1 ， seq = x 服务器：可以啊，我们建立连接吧 ！ -> ACK =1, SYN = 1, seq = y, ack = x+1 客户端：收到，建立连接吧！ -> ACK = 1, SYN = 1，seq = x + 1， ack = y + 1 然后建立TCP连接"><meta itemprop=datePublished content="2023-01-16T10:04:25+08:00"><meta itemprop=dateModified content="2023-01-16T10:04:25+08:00"><meta itemprop=wordCount content="130"><meta itemprop=keywords content="计算机网络,"><meta name=twitter:card content="summary"><meta name=twitter:title content="计算机网络-三次握手和四次挥手"><meta name=twitter:description content="三次握手和四次挥手 三次握手 概念 为什么需要握手：握手的作用就是为了同步一些信息，比如最大滑动窗口
TCP：是一个可靠的连接，也就是客户端和服务器双方必须感知对方的存在，也就是需要经历一个建立连接的过程
用三次握手建立TCP连接，连接有三个阶段
建立连接 数据传输 连接释放 连接的管理就是使连接的建立和释放都能正常地进行，连接阶段过程中要解决以下三个问题
要使每一方都能确知对方的存在 要允许双方协商一些参数 能够对运输实体分配资源 TCP连接建立过程 TCP建立连接的过程：被称为握手
① 握手过程其实是发送的TCP报文，在这里面有两个字段，SYN 和 seq
SYN = 1：表示w该报文不能携带数据，但是需要消耗一个SEQ（序号），可以想象成我们对消息编号 seq：TCP的每个字节发送的时候，都有一个序号，主要是为了保证可靠性，比如当我服务器通过TCP报文得到了有N个字节需要接受，但是最后只接受到了N-1个，我们通过序号就知道哪个没有被接收到。 客户端进入SYN_SENT状态，即同步已发送 ② 当服务器接受到我们的握手请求时，会回复一个确认报文
SYN：表示不携带数据，同时消耗一个SEQ = y（这里的y是任意数字，可以是1,2,3,4） ACK：=1 表示这是一条确定报文 ack：x+1，其中x是刚刚客户端发送过来的 服务器进入SYN_RECVD状态，即同步已收到 ③ 当客户端收到确认报文的时候，客户端需要对这个确认报文进行回复
ACK：=1，表示这是一条确认报文 seq：= x +1， ack：= y+1 经过了这三次握手，两者就进入了连接状态
通俗的理解 客户端：服务器，我们可以建立连接么？ -> SYN= 1 ， seq = x 服务器：可以啊，我们建立连接吧 ！ -> ACK =1, SYN = 1, seq = y, ack = x+1 客户端：收到，建立连接吧！ -> ACK = 1, SYN = 1，seq = x + 1， ack = y + 1 然后建立TCP连接"></head><body class="ma0 avenir bg-near-white"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib">test</a><div class="flex-l items-center"><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked">POSTS</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">计算机网络-三次握手和四次挥手</h1><time class="f6 mv4 dib tracked" datetime=2023-01-16T10:04:25+08:00>January 16, 2023</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h1 id=三次握手和四次挥手>三次握手和四次挥手</h1><h2 id=三次握手>三次握手</h2><h3 id=概念>概念</h3><p>为什么需要握手：握手的作用就是为了同步一些信息，比如最大滑动窗口</p><p>TCP：是一个可靠的连接，也就是客户端和服务器双方必须感知对方的存在，也就是需要经历一个建立连接的过程</p><p>用三次握手建立TCP连接，连接有三个阶段</p><ul><li>建立连接</li><li>数据传输</li><li>连接释放</li></ul><p>连接的管理就是使连接的建立和释放都能正常地进行，连接阶段过程中要解决以下三个问题</p><ul><li>要使每一方都能确知对方的存在</li><li>要允许双方协商一些参数</li><li>能够对运输实体分配资源</li></ul><h3 id=tcp连接建立过程>TCP连接建立过程</h3><p>TCP建立连接的过程：被称为握手</p><p><img src=https://typorastore.oss-cn-beijing.aliyuncs.com/img/image-20200412155010409.png alt=image-20200412155010409></p><p>① 握手过程其实是发送的TCP报文，在这里面有两个字段，SYN 和 seq</p><ul><li>SYN = 1：表示w该报文不能携带数据，但是需要消耗一个SEQ（序号），可以想象成我们对消息编号</li><li>seq：TCP的每个字节发送的时候，都有一个序号，主要是为了保证可靠性，比如当我服务器通过TCP报文得到了有N个字节需要接受，但是最后只接受到了N-1个，我们通过序号就知道哪个没有被接收到。</li><li>客户端进入SYN_SENT状态，即同步已发送</li></ul><p>② 当服务器接受到我们的握手请求时，会回复一个确认报文</p><ul><li>SYN：表示不携带数据，同时消耗一个SEQ = y（这里的y是任意数字，可以是1,2,3,4）</li><li>ACK：=1 表示这是一条确定报文</li><li>ack：x+1，其中x是刚刚客户端发送过来的</li><li>服务器进入SYN_RECVD状态，即同步已收到</li></ul><p>③ 当客户端收到确认报文的时候，客户端需要对这个确认报文进行回复</p><ul><li>ACK：=1，表示这是一条确认报文</li><li>seq：= x +1，</li><li>ack：= y+1</li></ul><p>经过了这三次握手，两者就进入了连接状态</p><h3 id=通俗的理解>通俗的理解</h3><ul><li>客户端：服务器，我们可以建立连接么？ -> SYN= 1 ， seq = x</li><li>服务器：可以啊，我们建立连接吧 ！ -> ACK =1, SYN = 1, seq = y, ack = x+1</li><li>客户端：收到，建立连接吧！ -> ACK = 1, SYN = 1，seq = x + 1， ack = y + 1</li></ul><p>然后建立TCP连接</p><p>中国机长版三次握手</p><p><img src=https://typorastore.oss-cn-beijing.aliyuncs.com/img/image-20200412163516738.png alt=image-20200412163516738></p><h3 id=为什么是三次握手>为什么是三次握手</h3><h4 id=四次握手>四次握手</h4><p>四次连接有点多余，第三次的时候，我们已经互相进行了连接确认</p><p>但是因为我们无法保证百分百的可靠性</p><h4 id=两次握手>两次握手：</h4><p>客户端知道服务器有接收 和 发送的能力，服务器不知道客户端有没有接收数据的能力，因为通过第一次握手，已经知道了客户端能够发送数据，但是能不能接收数据，还是不清楚，因此这个TCP连接是不可靠的。</p><p>为什么不能两次握手就建立连接</p><p>因为超时重传机制的存在</p><p>但客户端发送第一次握手的时候，可能会经历网络拥塞，然后客户端会以为这个连接已经丢失，然后会重新发送一个请求连接的信息到服务器，这次发送的消息很快被服务器接受，然后服务器建立连接就开始建立连接。但是当第一次发送的请求经过一段时间的阻塞后，成功到达服务器，然后服务器又连接连接，而此时客户端是不会理会这次请求的建立，所以服务器一直在等待客户端数据的发送。</p><p><img src=https://typorastore.oss-cn-beijing.aliyuncs.com/img/image-20200412162156748.png alt=image-20200412162156748></p><h2 id=四次挥手>四次挥手</h2><p>所谓的四次挥手，就是关闭TCP连接的过程，指的是断开一个TPC连接，需要客户端和服务端总共发送4个包，以确定双方连接的断开。</p><p>主要目的：保证TCP连接的全双工连接</p><h3 id=四次挥手示意图>四次挥手示意图</h3><p><img src=https://typorastore.oss-cn-beijing.aliyuncs.com/img/20181120162254477.png alt=img></p><p>由于TCP连接是全双工的，因此每个方向都必须单独关闭，这个原则是当以防完成它的数据发送任务后，就能发送一个FIN包来终止这个方向的连接。</p><p>收到一个FIN包只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后，仍然能发送数据，首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><p>全双工 A和B能同时发送</p><p>fin包就终止一次</p><h3 id=四次挥手过程>四次挥手过程</h3><ul><li><strong>第一次挥手</strong>：客户端发送一个FIN包（FIN=1，seq=U）给服务器，用来关闭客户端到服务器端的数据传输，客户端进入FIN_WAIT_1状态（终止等待）</li><li><strong>第二次挥手</strong>：服务器端收到FIN包后，发送一个ACK包（ACK=1，ack=u+1，在随机产生一个值v 给seq）给客户端，服务器进入了CLOSE_WAIT状态（关闭等待）</li><li><strong>第三次挥手</strong>：服务器端发送一个FIN包（FIN=1，ACK=1，ack=u+1，在随机产生 一个w值给seq）给客户端，用来关闭服务器到客户端的数据传输，服务端进入了LAST_ACK（最后确定）状态</li><li><strong>第四次挥手</strong>：客户端接收FIN包，然后进入TIME_WAIT状态，接着发送一个ACK包（ACK=1，seq=u+1, ack = w+1） 给服务端，服务端确定序号，进入CLOSe状态，完成了四次挥手。</li></ul><h3 id=挥手中的状态>挥手中的状态</h3><ul><li>CLOSED：表示初始状态</li><li>ESTABLISHED：表示连接已经连接</li><li>FIN_WAIT：状态FIN_WAIT_1和FIN_WAIT_2都表示等待对方的FIN报文，这两个状态的区别是，当主动发送方给对方发送了断开请求时，就进入了FIN_WAIT_1状态，而到被动方在回应后，主动发送方就进入了FIN_WAIT_2。</li><li><strong>FIN_WAIT_2</strong>：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你，稍后再关闭连接</li><li>CLOSE_WAIT：这个状态的含义是 表示在等待关闭</li><li>LAST_ACK：在被动关闭放发送FIN报文后，最后等待对方的ACK报文，当收到了ACK报文后，就进入了CLOSE状态。</li></ul><h3 id=为什么time_wait状态还需要等待2msl后才能返回close>为什么TIME_WAIT状态还需要等待2MSL后才能返回CLOSE</h3><p>这是因为虽然双方都同意了关闭连接，而且握手的4个报文也都协调和发送完毕，按道理可以直接回到CLOSE状态</p><p>但是因为我们需要假设网络是不可靠的，你无法保证你最后发送的ACK报文是会一定被对方收到，因此处于LAST_ACK状态下的socket可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的报文。</p><h3 id=中国机长版四次挥手>中国机长版四次挥手</h3><p>当客户端与服务器在规定的时间内没有得到应答</p><p>会发送报文进行探测，假设没有应答，那么就会关闭连接</p><p><img src=https://typorastore.oss-cn-beijing.aliyuncs.com/img/image-20200412163756161.png alt=image-20200412163756161></p><p>下面是四次挥手的过程</p><p><img src=https://typorastore.oss-cn-beijing.aliyuncs.com/img/image-20200412165407014.png alt=image-20200412165407014></p><ul class=pa0><li class="list di"><a href=/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">计算机网络</a></li></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://Zelayan.github.io/>&copy; test 2023</a><div><div class=ananke-socials></div></div></div></footer></body></html>